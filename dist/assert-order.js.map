{"version":3,"file":"assert-order.js","sources":["../../../../../../assert-order/assertOrder.ts","../../../../../../assert-order/index.ts"],"sourcesContent":["export interface Steps {\n  once?: number[]\n  some?: number[]\n  all?: number[]\n}\n\nexport class AssertOrder {\n  private static alias = {\n    step: 'once',\n    any: 'once'\n  }\n  private static reverseAlias = {\n    once: ['step'],\n    some: [],\n    all: []\n  }\n\n  /**\n   * Gets what is the next expecting step.\n   * If the current step is `some(n)`, this reflects the step after `some(n)`\n   */\n  public get next() { return this.nextStep }\n  private nextStep: number\n  private possibleMoves: Steps\n  private miniSteps = 0\n  private targetMiniSteps: number | undefined\n  constructor(public plannedSteps?: number, initStep = 0) {\n    this.nextStep = initStep\n    this.possibleMoves = {\n      once: [initStep],\n      some: [initStep],\n      all: [initStep]\n    }\n  }\n\n  /**\n   * Verify all planned steps are executed.\n   * @param timeout If specified, will return a promise that resolve after the specified time (in milliseconds) or rejected if failed.\n   */\n  end(timeout: number): Promise<never>\n  end(): void\n  end(timeout?: number) {\n    const check = (() => {\n      return this.plannedSteps === undefined || this.nextStep === this.plannedSteps\n    })\n    const getErrorMsg = () => `Planned ${this.plannedSteps} steps but executed ${this.nextStep} steps`\n\n    if (timeout) {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          if (check()) {\n            resolve()\n          }\n          else {\n            reject(new Error(getErrorMsg()))\n          }\n        }, timeout);\n      })\n    }\n\n    if (!check()) {\n      throw new Error(getErrorMsg())\n    }\n  }\n\n  step(step: number) {\n    if (this.isValidStep('step', [step])) {\n      this.moveNext()\n      return this.nextStep++\n    }\n    else {\n      throw new Error(this.getErrorMessage('step', step))\n    }\n  }\n\n  /**\n   * Assert the specified step will run once.\n   */\n  once(step: number) {\n    // this.validate('once', [step], 1)\n    if (this.isValidStep('once', [step])) {\n      this.moveNext()\n      return this.nextStep++\n    }\n    else {\n      throw new Error(this.getErrorMessage('once', step))\n    }\n  }\n\n  /**\n   * Assert this place will be called during any of the specified steps.\n   * @returns the step it is being called right now.\n   */\n  any(...anySteps: number[]) {\n    if (this.isValidStep('any', anySteps)) {\n      this.moveNext()\n      return this.nextStep++\n    }\n    else {\n      throw new Error(this.getErrorMessage('any', ...anySteps))\n    }\n  }\n\n  /**\n   * Assert the specified step will be reached at least once.\n   * @returns how many times this step has occured.\n   */\n  some(step: number) {\n    if (this.isValidStep('some', [step])) {\n      if (step === this.nextStep) {\n        this.moveNext({\n          once: [step + 1],\n          some: [step, step + 1],\n          all: [step + 1]\n        })\n        this.miniSteps = 0\n        this.nextStep++\n      }\n\n      return ++this.miniSteps\n    }\n    else {\n      throw new Error(this.getErrorMessage('some', step))\n    }\n  }\n\n  /**\n   * Assert the specified step will be reached x times.\n   * @returns how many times this step has occured.\n   */\n  all(step: number, plan: number) {\n    if (plan <= 0) {\n      throw new Error(`${plan} is not a valid 'plan' value.`)\n    }\n    if (this.targetMiniSteps && this.targetMiniSteps !== plan) {\n      throw new Error(`The plan count (${plan}) does not match with previous value (${this.targetMiniSteps}).`)\n    }\n\n    if (this.isValidStep('all', [step], plan)) {\n      if (this.targetMiniSteps === undefined) {\n        this.targetMiniSteps = plan\n        this.miniSteps = 0\n        this.moveNext({\n          all: [step]\n        })\n      }\n\n      this.miniSteps++\n      if (plan === this.miniSteps) {\n        this.moveNext()\n        this.nextStep++\n        this.targetMiniSteps = undefined\n      }\n      return this.miniSteps\n    }\n    else {\n      throw new Error(this.getErrorMessage('all', step))\n    }\n  }\n\n  private isValidStep(fnName: string, steps: number[], count?: number) {\n    // console.log(`${fnName}(${steps}${count ? ',' + count : ''}), c: ${this.currentStep}, m: ${this.miniSteps}`, this.possibleMoves)\n    const id = AssertOrder.alias[fnName] || fnName\n    const step = steps.find(s => this.possibleMoves[id] && this.possibleMoves[id].some(x => x === s))\n    return (!count || this.miniSteps <= count) && step !== undefined\n  }\n  private moveNext(nextMoves: Steps = {\n    once: [this.nextStep + 1],\n    some: [this.nextStep + 1],\n    all: [this.nextStep + 1]\n  }) {\n    this.possibleMoves = nextMoves\n  }\n\n  private getErrorMessage(calledFn: string, ...calledSteps: number[]) {\n    const should: string[] = []\n    for (let key in this.possibleMoves) {\n      should.push(...([key, ...AssertOrder.reverseAlias[key]].map(name =>\n        `'${name}(${this.possibleMoves[key].join('|')})'`\n      )))\n    }\n\n    return `Expecting ${should.join(', ')}, but received '${calledFn}(${calledSteps.join(',')})'`\n  }\n}\n","import { AssertOrder } from './assertOrder'\nexport default AssertOrder\n"],"names":["plannedSteps","initStep","this","nextStep","possibleMoves","once","some","all","Object","AssertOrder","timeout","check","undefined","_this","getErrorMsg","Promise","resolve","reject","setTimeout","Error","step","isValidStep","moveNext","getErrorMessage","_i","anySteps","miniSteps","plan","targetMiniSteps","fnName","steps","count","id","alias","find","s","x","nextMoves","calledFn","calledSteps","should","key","push","reverseAlias","map","name","join","any","exports","assertOrder_1"],"mappings":"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"}